#!/usr/bin/python  
#! -*- coding=utf-8 -*-  
import sys, os  
import subprocess
import time
  
cmdline=""
home_dir=""
pid_file=""
lockfile=""
start_mode="normal"

  
def daemonize (target_dir,stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):  
     #重定向标准文件描述符（默认情况下定向到/dev/null）  
    try:   
        pid = os.fork()   
          #父进程(会话组头领进程)退出，这意味着一个非会话组头领进程永远不能重新获得控制终端。  
        if pid > 0:  
            sys.exit(0)   #父进程退出  
    except OSError, e:   
        sys.stderr.write ("fork #1 failed: (%d) %s\n" % (e.errno, e.strerror) )  
        sys.exit(1)  
  
     #从母体环境脱离  
    os.chdir(target_dir)  #chdir确认进程不保持任何目录于使用状态，否则不能umount一个文件系统。也可以改变到对于守护程序运行重要的文件所在目录  
    os.umask(0)    #调用umask(0)以便拥有对于写的任何东西的完全控制，因为有时不知道继承了什么样的umask。  
    os.setsid()    #setsid调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。  
  
     #执行第二次fork  
    try:   
        pid = os.fork()   
        if pid > 0:  
            sys.exit(0)   #第二个父进程退出  
    except OSError, e:   
        sys.stderr.write ("fork #2 failed: (%d) %s\n" % (e.errno, e.strerror) )  
        sys.exit(1)  
  
     #进程已经是守护进程了，重定向标准文件描述符  
  
    for f in sys.stdout, sys.stderr: f.flush()  
    si = open(stdin, 'r')  
    so = open(stdout, 'a+')  
    se = open(stderr, 'a+', 0)  
    os.dup2(si.fileno(), sys.stdin.fileno())    #dup2函数原子化关闭和复制文件描述符  
    os.dup2(so.fileno(), sys.stdout.fileno())  
    os.dup2(se.fileno(), sys.stderr.fileno())  
  
#示例函数：每秒打印一个数字和时间戳  


def debug_mode():
    
        cmd_object=subprocess.Popen(cmdline,shell=True,stdin=None,stdout=None, stderr=None )
        the_pid=str(cmd_object.pid)
        print the_pid


def ever_process():
        f_h=open(pid_file,"r")
        the_pid=f_h.read().strip()
        f_h.close()
        if pid_run_status(int(the_pid))==True:
            subprocess.call("kill -9 "+the_pid,shell=True,stdin=None,stdout=None, stderr=None )
        
        cmd_object=subprocess.Popen(cmdline,shell=True,stdin=None,stdout=None, stderr=None )
        time.sleep(0.5)
        f_h=open(pid_file,"r")
        the_pid=f_h.read().strip()
        f_h.close()

        print the_pid
        the_real_cmd=get_now_run_cmdline(the_pid)
        print the_real_cmd
        if the_real_cmd is not None:
            f_h_lockfile=open(lockfile,"w")
            f_h_lockfile.write(the_real_cmd)
            f_h_lockfile.close()
            f_h=open(pid_file+"._parent_pid","w")
            f_h.write(str(os.getpid))
            f_h.close()
            
            
            while True:
                if check_pid_run(int(the_pid))==False:
                    cmd_object=subprocess.Popen(cmdline,shell=True,stdin=None,stdout=None, stderr=None )
                    time.sleep(0.5)
                    f_h=open(pid_file,"r")
                    the_pid=f_h.read().strip()  
                    f_h.close()
                time.sleep(0.5)
            
    
    

def start_process():
    cmd_object=subprocess.Popen(cmdline,shell=True,stdin=None,stdout=None, stderr=None )
    the_pid=str(cmd_object.pid)
    f_h=open(pid_file,"w")
    f_h.write(the_pid)
    f_h.close()
    time.sleep(0.5)
    the_real_cmd=get_now_run_cmdline(the_pid)
    if the_real_cmd is not None:
        f_h_lockfile=open(lockfile,"w")
        f_h_lockfile.write(the_real_cmd)
        f_h_lockfile.close()
    
        
    

def get_after_shell_part(sys_argv,from_which=2,end_count=1):
    arg_list=[]
    sys_len=len(sys_argv)
    for i in range(from_which,sys_len-end_count):
        arg_list.append(sys_argv[i])
    return arg_list 
    
def stop_process(pidfile):
    pid_num=check_pid_file(pidfile)
    if pid_num is not None:
        print "stop it"
        cmd_object=subprocess.call("kill -TERM "+str(pid_num),shell=True)
        print "try normal end it "
        time_out_set=10
        start_now_time=time.time()
        while True:
            # check pid dead
            if check_pid_file(pidfile) is None:
                print "normal end it success"
                return True
            time.sleep(0.1)
            if time_out_set+start_now_time<time.time():
                subprocess.call("kill -KILL "+str(pid_num),shell=True)
                print "force kill it"
                return True
                
        return True
    else:
        print "not running, skip stop"
        return False
    
def is_num_by_except(num):
    try:
        int(num)
        return True
    except ValueError:
#        print "%s ValueError" % num
        return False    
    
def check_pid_file(pidfile):
    if os.path.exists(pidfile)==True:
        f_h=open(pid_file,"r")
        f_c=f_h.read().strip()
        f_h.close()
        if is_num_by_except(f_c)==True:
            
            if check_pid_run(int(f_c))==True:
                # print f_c+" running"
                return int(f_c)
            else:
                # print "not running"
                return None
        else:
            # print "not running"
            return None
            
def pid_run_status(pid_num):
    
    if os.path.exists("/proc/"+str(pid_num)+"/cmdline")==True: 
        return True
    else:
        return False
    
            
def get_now_run_cmdline(pid_num):
    
    if os.path.exists("/proc/"+str(pid_num)+"/cmdline")==True: 
        f_h=open("/proc/"+str(pid_num)+"/cmdline","r")
        in_cmd_line=f_h.read().strip()
        f_h.close()
        return in_cmd_line
    else:
        return None
            
def check_pid_run(pid_num):
    if os.path.exists(lockfile)==True:
    
        f_h_lockfile=open(lockfile,"r")
        f_c=f_h_lockfile.read().strip()
        f_h_lockfile.close()
        now_cmdline=get_now_run_cmdline(pid_num)
        if f_c==now_cmdline:
            return True
        else:
            return False
    else:
        return False
    
def show_usage():
    print "version: 1.3"
    print "usage: [pid_path] [lock_path] [cmdline many part] [start|stop|restart|status]"
    print "or usage:  -r [pid_path] [lock_path] [run_dir] [stdout] [stderr] [cmdline many part] [start|stop|restart|status]"

    
  
if __name__ == "__main__":  
    if len(sys.argv)>4:

        if sys.argv[1]=="-r":
            if len(sys.argv)>8:
                run_mode=sys.argv[1]
                pid_file=sys.argv[2]
                lockfile=sys.argv[3]
                run_dir=sys.argv[4]
                daemon_stdout=sys.argv[5]
                daemon_stderr=sys.argv[6]
            else:
                show_usage()
                sys.exit(1)
        
        else:
            pid_file=sys.argv[1]
            lockfile=sys.argv[2]
            run_dir="/"
            daemon_stdout="/dev/null"
            daemon_stderr="/dev/null"
            if sys.argv[3].strip()=="" or sys.argv[3].strip()=="null":
                show_usage()
                sys.exit(1)
                
        if sys.argv[1]=="-r":
        
            if sys.argv[-1]=="debug" or sys.argv[-1]=="ever" or sys.argv[-1]=="start" or sys.argv[-1]=="stop" or sys.argv[-1]=="restart" or sys.argv[-1]=="status":
                cmdline_org_list=get_after_shell_part(sys.argv,from_which=7,end_count=1)
            else:
                cmdline_org_list=get_after_shell_part(sys.argv,from_which=7,end_count=0)
            cmdline=" ".join(cmdline_org_list)
            
        else:
        
            if sys.argv[-1]=="debug" or sys.argv[-1]=="ever" or sys.argv[-1]=="start" or sys.argv[-1]=="stop" or sys.argv[-1]=="restart" or sys.argv[-1]=="status":
                cmdline_org_list=get_after_shell_part(sys.argv,from_which=3,end_count=1)
            else:
                cmdline_org_list=get_after_shell_part(sys.argv,from_which=3,end_count=0)
            cmdline=" ".join(cmdline_org_list)
            


        
        if run_dir=="null"  or run_dir==" " or run_dir=="":
            run_dir="/"
  
        
        if os.path.exists(run_dir)==False:
            print "[Error] run dir not exists"
        
        if daemon_stdout=="null" or daemon_stdout=="" or daemon_stdout==" ":
            daemon_stdout="/dev/null"
            
        if  daemon_stderr=="null" or daemon_stderr=="" or daemon_stderr==" ":
             daemon_stderr="/dev/null"
             
        print "pid_file: "+pid_file
        print "lockfile: "+lockfile
        print "run_dir: "+run_dir
        print "daemon_stdout: "+daemon_stdout
        print "daemon_stderr: "+daemon_stderr
        print cmdline
        
        if sys.argv[-1]=="ever":
            daemonize(run_dir,'/dev/null',daemon_stdout,daemon_stderr)  
            ever_process()
        if sys.argv[-1]=="debug":
    
            debug_mode()
        
        if sys.argv[-1]=="start":
            if check_pid_file(pid_file) is None:
                print "starting..."
                #pass
                daemonize(run_dir,'/dev/null',daemon_stdout,daemon_stderr)  
                start_process()
            else:
                print "already running"
            
        if sys.argv[-1]=="stop":
     
            stop_process(pid_file)
        if sys.argv[-1]=="restart":
            print "restart..."
            stop_process(pid_file)
            time.sleep(1)
            if check_pid_file(pid_file) is None:
                print "start...."
                daemonize(run_dir,'/dev/null',daemon_stdout,daemon_stderr)  
                start_process()
            else:
                print "already running"
        if sys.argv[-1]=="status":
            if check_pid_file(pid_file) is not None:
                print "already running"
            else:
                print "not running"
            
    else:
        show_usage()
        sys.exit(1)
    
